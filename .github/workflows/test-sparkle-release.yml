name: Test Sparkle Release (Safe)

on:
  workflow_dispatch:
    inputs:
      version_increment:
        description: 'Version increment type (TEST ONLY - no actual release)'
        required: true
        default: 'patch'
        type: choice
        options:
        - major
        - minor
        - patch
      release_notes:
        description: 'Test release notes'
        required: false
        type: string
        default: 'TEST RELEASE - This is a test run of the automation'

jobs:
  test-release:
    runs-on: macos-latest
    
    steps:
    - name: ‚ö†Ô∏è TEST MODE WARNING
      run: |
        echo "üß™ THIS IS A TEST RUN - NO ACTUAL RELEASE WILL BE CREATED"
        echo "üìã This workflow will:"
        echo "   ‚úÖ Test version calculation"
        echo "   ‚úÖ Test project file parsing"
        echo "   ‚úÖ Test build process (dry run)"
        echo "   ‚úÖ Test appcast generation"
        echo "   ‚ùå Will NOT create GitHub release"
        echo "   ‚ùå Will NOT push changes to repository"
        echo "   ‚ùå Will NOT upload any assets"
        echo ""
    
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.ref }}
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get current version
      id: current_version
      run: |
        CURRENT_VERSION=$(grep -o 'MARKETING_VERSION = [0-9.]*' DockDoor.xcodeproj/project.pbxproj | head -1 | cut -d' ' -f3 | tr -d ';')
        echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "‚úÖ Current version detected: $CURRENT_VERSION"
    
    - name: Calculate new version (TEST)
      id: new_version  
      run: |
        CURRENT="${{ steps.current_version.outputs.current }}"
        IFS='.' read -ra VERSION_PARTS <<< "$CURRENT"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]}
        
        case "${{ github.event.inputs.version_increment }}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "new=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "‚úÖ Would increment to: $NEW_VERSION"
        echo "üìä Version change: $CURRENT ‚Üí $NEW_VERSION (${{ github.event.inputs.version_increment }})"
    
    - name: Test version update (dry run)
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new }}"
        echo "üîç Testing version update process..."
        
        # Create backup of project file
        cp DockDoor.xcodeproj/project.pbxproj DockDoor.xcodeproj/project.pbxproj.backup
        
        # Test the sed commands
        sed -i '' "s/MARKETING_VERSION = [0-9.]*/MARKETING_VERSION = $NEW_VERSION/g" DockDoor.xcodeproj/project.pbxproj
        sed -i '' "s/CURRENT_PROJECT_VERSION = [0-9.]*/CURRENT_PROJECT_VERSION = $NEW_VERSION/g" DockDoor.xcodeproj/project.pbxproj
        
        # Verify changes
        echo "‚úÖ Version replacement test successful:"
        grep "MARKETING_VERSION = " DockDoor.xcodeproj/project.pbxproj | head -2
        grep "CURRENT_PROJECT_VERSION = " DockDoor.xcodeproj/project.pbxproj | head -2
        
        # Restore original file
        mv DockDoor.xcodeproj/project.pbxproj.backup DockDoor.xcodeproj/project.pbxproj
        echo "‚úÖ Original project file restored"
    
    - name: Build and Create DMG
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "üî® Building app and creating DMG..."
        
        # Clean build folder
        rm -rf build/
        
        # Create ExportOptions.plist with actual team ID
        cat > ExportOptions.plist << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>method</key>
            <string>developer-id</string>
            <key>teamID</key>
            <string>$APPLE_TEAM_ID</string>
            <key>uploadBitcode</key>
            <false/>
            <key>uploadSymbols</key>
            <true/>
            <key>compileBitcode</key>
            <false/>
            <key>signingStyle</key>
            <string>automatic</string>
            <key>stripSwiftSymbols</key>
            <true/>
        </dict>
        </plist>
        EOF
        
        # Build for release
        xcodebuild -project DockDoor.xcodeproj \
          -scheme DockDoor \
          -configuration Release \
          -derivedDataPath build/ \
          -archivePath build/DockDoor.xcarchive \
          archive
        
        # Export the app
        xcodebuild -exportArchive \
          -archivePath build/DockDoor.xcarchive \
          -exportPath build/export \
          -exportOptionsPlist ExportOptions.plist
        
        # Create proper DMG with Applications shortcut
        APP_PATH="build/export/DockDoor.app"
        DMG_PATH="build/DockDoor.dmg"
        TEMP_DMG_DIR="build/dmg_temp"
        
        if [ -d "$APP_PATH" ]; then
          # Create temporary directory for DMG contents
          mkdir -p "$TEMP_DMG_DIR"
          
          # Copy app to temp directory
          cp -R "$APP_PATH" "$TEMP_DMG_DIR/"
          
          # Create symbolic link to Applications
          ln -s /Applications "$TEMP_DMG_DIR/Applications"
          
          # Create DMG with proper drag-and-drop layout
          hdiutil create -volname "DockDoor" -srcfolder "$TEMP_DMG_DIR" -ov -format UDZO "$DMG_PATH"
          
          # Clean up temp directory
          rm -rf "$TEMP_DMG_DIR"
          
          echo "‚úÖ DMG created at $DMG_PATH with Applications shortcut"
          
          # Show DMG info
          DMG_SIZE=$(stat -f%z "$DMG_PATH")
          echo "üì¶ DMG Size: $DMG_SIZE bytes"
          ls -lah "$DMG_PATH"
        else
          echo "‚ùå Error: App not found at $APP_PATH"
          exit 1
        fi
    
    - name: Upload DMG as Artifact
      uses: actions/upload-artifact@v4
      with:
        name: DockDoor-Test-v${{ steps.new_version.outputs.new }}
        path: build/DockDoor.dmg
        retention-days: 7
    
    - name: Generate and Display Appcast
      env:
        SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
      run: |
        echo "üì° Generating actual appcast with real DMG..."
        
        NEW_VERSION="${{ steps.new_version.outputs.new }}"
        DMG_SIZE=$(stat -f%z build/DockDoor.dmg)
        DOWNLOAD_URL="https://github.com/ejbills/DockDoor/releases/latest/download/DockDoor.dmg"
        
        echo "üìä DMG Info:"
        echo "  Version: $NEW_VERSION"
        echo "  Size: $DMG_SIZE bytes"
        echo "  Download URL: $DOWNLOAD_URL"
        echo ""
        
        # Generate appcast with proper signatures using Sparkle's tool
        if [ -n "$SPARKLE_PRIVATE_KEY" ]; then
          echo "üîê Generating SIGNED appcast with Sparkle tool..."
          
          # Create a temporary directory for appcast generation
          mkdir -p temp_appcast
          cp build/DockDoor.dmg "temp_appcast/DockDoor-$NEW_VERSION.dmg"
          
          # Save private key to temporary file
          echo "$SPARKLE_PRIVATE_KEY" > temp_private_key.pem
          
          # Generate appcast with signatures
          ./Sparkle/generate_appcast \
            --ed-key-file temp_private_key.pem \
            --download-url-prefix "https://github.com/ejbills/DockDoor/releases/latest/download/" \
            --release-notes-url-prefix "https://dockdoor.net/CHANGELOG.html" \
            temp_appcast/
          
          echo "‚úÖ SIGNED Appcast generated:"
          echo "=========================="
          cat temp_appcast/appcast.xml
          echo "=========================="
          
          # Clean up
          rm -f temp_private_key.pem
          rm -rf temp_appcast
        else
          echo "‚ö†Ô∏è Generating UNSIGNED appcast (SPARKLE_PRIVATE_KEY not set)..."
          CURRENT_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          
          echo "‚úÖ UNSIGNED Appcast would be:"
          echo "=========================="
          cat << 'EOF'
        <?xml version="1.0" standalone="yes"?>
        <rss xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" version="2.0">
            <channel>
                <title>DockDoor</title>
                <item>
                    <title>$NEW_VERSION</title>
                    <pubDate>$CURRENT_DATE</pubDate>
                    <sparkle:releaseNotesLink>https://dockdoor.net/CHANGELOG.html</sparkle:releaseNotesLink>
                    <sparkle:version>$NEW_VERSION</sparkle:version>
                    <sparkle:shortVersionString>$NEW_VERSION</sparkle:shortVersionString>
                    <sparkle:minimumSystemVersion>13.0</sparkle:minimumSystemVersion>
                    <enclosure url="$DOWNLOAD_URL" length="$DMG_SIZE" type="application/octet-stream"/>
                </item>
            </channel>
        </rss>
        EOF
          echo "=========================="
        fi
    
    - name: Test Sparkle signing (if configured)
      run: |
        if [ -n "${{ secrets.SPARKLE_PRIVATE_KEY }}" ]; then
          echo "‚úÖ SPARKLE_PRIVATE_KEY secret is configured"
          echo "üîê Sparkle signing would be enabled in real release"
        else
          echo "‚ö†Ô∏è  SPARKLE_PRIVATE_KEY secret not configured"
          echo "üìù Appcast would be generated without signatures"
        fi
        
        if [ -n "${{ secrets.APPLE_TEAM_ID }}" ]; then
          echo "‚úÖ APPLE_TEAM_ID secret is configured"
        else
          echo "‚ö†Ô∏è  APPLE_TEAM_ID secret not configured"
        fi
    
    - name: Test release notes generation
      run: |
        echo "üìù Testing release notes generation..."
        
        if [ -n "${{ github.event.inputs.release_notes }}" ]; then
          echo "‚úÖ Using provided release notes:"
          echo "${{ github.event.inputs.release_notes }}"
        else
          echo "üìÑ Would extract from CHANGELOG.md:"
          if [ -f "CHANGELOG.md" ]; then
            echo "‚úÖ CHANGELOG.md found"
            # Show what would be extracted
            awk '/^## \[/ {if(found) exit; found=1; next} found && /^## \[/ {exit} found {print}' CHANGELOG.md | head -10
          else
            echo "‚ö†Ô∏è  CHANGELOG.md not found, would use default notes"
          fi
        fi
    
    - name: üéâ Test Summary
      run: |
        echo "üß™ TEST COMPLETE - Summary:"
        echo "================================="
        echo "Current Version: ${{ steps.current_version.outputs.current }}"
        echo "Would Create: v${{ steps.new_version.outputs.new }}"
        echo "Increment Type: ${{ github.event.inputs.version_increment }}"
        echo "Branch: ${{ github.ref_name }}"
        echo ""
        echo "‚úÖ Version calculation: PASSED"
        echo "‚úÖ Project file updates: PASSED" 
        echo "‚úÖ Build configuration: PASSED"
        echo "‚úÖ Appcast generation: PASSED"
        echo ""
        echo "üöÄ Ready for real release? Run 'Sparkle Release Automation' workflow"
        echo "‚ö†Ô∏è  Remember to merge this branch to main first if testing on a feature branch"
